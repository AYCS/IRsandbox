[{"id":715023,"title":"Tab is not working while using for compilation","body":"<p>i am using ubuntu 14.04LTE. i write a  program in c with .c extension.when i try to compile i wrote the first alphabate of my file name and then i pressed tab it should have give me the filename,but that is not working. can anybody give me the solution.</p>\n","related_questions":[{"id":663501,"title":"How do I change the final location of a compiled c program in the terminal","body":"<p>After a c program is compiled it is stored in <code>./a.out</code>.  </p>\n\n<p>Is there any way in which I can change the file to any name I want?</p>\n"},{"id":420722,"title":"how to compile a c program that uses pthread.h?","body":"<p>I'm a beginner and I'm new to Ubuntu. I just installed it and want to run a C program. I have no idea what platform to use or where to write the code. I need to use pthread.h header file in the program. Can anyone help me?</p>\n"},{"id":278166,"title":"libusb program not compiling","body":"<p>I am trying to compile a program that uses <code>libusb</code> library in Ubuntu 12.04.</p>\n\n<p>I have installed the <code>libusb-1.0-0-dev</code>. However, when I try to compile a program as below:</p>\n\n<pre><code>#include&lt;usb.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;libusb-1.0/libusb.h&gt;\nint main()\n{\n       libusb_init(NULL);            \n       return 0;\n}\n</code></pre>\n\n<p>It gives me an error saying</p>\n\n<pre><code>/tmp/ccb75YtE.o: In function 'main':\nusb.c:(.text+0x11): undefined reference to 'libusb_init'\ncollect2: ld returned 1 exit status\n</code></pre>\n\n<p>I am using the  command <code>cc &lt;file name&gt; -lusb</code> to compile it.\nWhat could be the problem?</p>\n"},{"id":631819,"title":"error with .data file,C","body":"<p>I have been trying to compile a C program that receives data from a .data file.Unfortunately,I always get the following message:\ninput.dat.2:1:error: expected identifier or \"(\" before numeric constant\nI am using the 2014 version of Ubuntu Linux.Actually,this is my first program at Linux environment.It is homework for my university.The same program worked for windows dev-C++!\nThis is the program:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include \"input.dat\"\n#define NUM_NODES                          100\n#define NONE                               9999\n#include&lt;csdl_queue.h&gt;\n#include&lt;cdsl_deque.h&gt;\n#include&lt;cdsl_dyn_array.h&gt;\n\nstruct _NODE\n{\n  int iDist;\n  int iPrev;\n};\ntypedef struct _NODE NODE;\n\nstruct _QITEM\n{\n  int iNode;\n  int iDist;\n  int iPrev;\n  struct _QITEM *qNext;\n};\ntypedef struct _QITEM QITEM;\n\nQITEM *qHead = NULL;\n\nint AdjMatrix[NUM_NODES][NUM_NODES];\n\nint g_qCount = 0;\nNODE rgnNodes[NUM_NODES];\nint ch;\nint iPrev, iNode;\nint i, iCost, iDist;\n\n\nvoid print_path (NODE *rgnNodes, int chNode)\n{\n  if (rgnNodes[chNode].iPrev != NONE)\n    {\n      print_path(rgnNodes, rgnNodes[chNode].iPrev);\n    }\n  printf (\" %d\", chNode);\n  fflush(stdout);\n}\n\n\nvoid enqueue (int iNode, int iDist, int iPrev)\n{\n  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));\n  QITEM *qLast = qHead;\n\n  if (!qNew) \n    {\n      fprintf(stderr, \"Out of memory.\\n\");\n      exit(1);\n    }\n  qNew-&gt;iNode = iNode;\n  qNew-&gt;iDist = iDist;\n  qNew-&gt;iPrev = iPrev;\n  qNew-&gt;qNext = NULL;\n\n  if (!qLast) \n    {\n      qHead = qNew;\n    }\n  else\n    {\n      while (qLast-&gt;qNext) qLast = qLast-&gt;qNext;\n      qLast-&gt;qNext = qNew;\n    }\n  g_qCount++;\n\n}\n\n\nvoid dequeue (int *piNode, int *piDist, int *piPrev)\n{\n  QITEM *qKill = qHead;\n\n  if (qHead)\n    {\n\n      *piNode = qHead-&gt;iNode;\n      *piDist = qHead-&gt;iDist;\n      *piPrev = qHead-&gt;iPrev;\n      qHead = qHead-&gt;qNext;\n      free(qKill);\n      g_qCount--;\n    }\n}\n\n\nint qcount (void)\n{\n  return(g_qCount);\n}\n\nint dijkstra(int chStart, int chEnd) \n{\n\n\n\n  for (ch = 0; ch &lt; NUM_NODES; ch++)\n    {\n      rgnNodes[ch].iDist = NONE;\n      rgnNodes[ch].iPrev = NONE;\n    }\n\n  if (chStart == chEnd) \n    {\n      printf(\"Shortest path is 0 in cost. Just stay where you are.\\n\");\n    }\n  else\n    {\n      rgnNodes[chStart].iDist = 0;\n      rgnNodes[chStart].iPrev = NONE;\n\n      enqueue (chStart, 0, NONE);\n\n     while (qcount() &gt; 0)\n    {\n      dequeue (&amp;iNode, &amp;iDist, &amp;iPrev);\n      for (i = 0; i &lt; NUM_NODES; i++)\n        {\n          if ((iCost = AdjMatrix[iNode][i]) != NONE)\n        {\n          if ((NONE == rgnNodes[i].iDist) || \n              (rgnNodes[i].iDist &gt; (iCost + iDist)))\n            {\n              rgnNodes[i].iDist = iDist + iCost;\n              rgnNodes[i].iPrev = iNode;\n              enqueue (i, iDist + iCost, iNode);\n            }\n        }\n        }\n    }\n\n      printf(\"Shortest path is %d in cost. \", rgnNodes[chEnd].iDist);\n      printf(\"Path is: \");\n      print_path(rgnNodes, chEnd);\n      printf(\"\\n\");\n    }\n}\n\nint main() {\n  int i,j,k;\n  FILE *fp;\n\n  fp=fopen(\"input.dat\",\"r\");\n  /* open the adjacency matrix file */\n  /* make a fully connected matrix */\n  for (i=0;i&lt;NUM_NODES;i++) {\n    for (j=0;j&lt;NUM_NODES;j++) {\n      /* make it more sparce */\n      fscanf(fp,\"%d\",&amp;k);\n    AdjMatrix[i][j]= k;\n    }\n  }\n\n  /* finds 10 shortest paths between nodes */\n  for (i=0,j=NUM_NODES/2;i&lt;20;i++,j++) {\n            j=j%NUM_NODES;\n      dijkstra(i,j);\n  }\n  fclose(fp);\n  exit(0);\n\n\n}\n</code></pre>\n\n<p>The program probably works,as it was granted to us by the teachers.The input.dat is composed only of numbers.I guess that the Ububtu system is somehow responsible.Why does the compilation proccess fail?I would be gratefull if anyone could help me!</p>\n"},{"id":613107,"title":"conio.h header file giving an error during compiling C program in ubuntu","body":"<p>My code for a simple C program is </p>\n\n<pre><code>#include&lt;stdio.h&gt;\n #include&lt;conio.h&gt;\nvoid main()\n{\n    printf(\"This is demo program \\n\");\n    getch();\n}\n</code></pre>\n\n<p>when I am trying to run this c program. I am getting a fatal error.</p>\n\n<pre><code>hello.c:2:18: fatal error: conio.h: No such file or directory\n #include&lt;conio.h&gt;\n                  ^\ncompilation terminated.\n</code></pre>\n\n<p>Please help me to come out of this problem.</p>\n"},{"id":422149,"title":"Compilation Help on Ubuntu 13.10","body":"<p>I have recently gotten into programming this is a small C code I started on.</p>\n\n<p>I am using Ubuntu 13.10.</p>\n\n<pre><code>int main(int argc, char *argv[])\n\n{\n\n    puts(\"Hello world.\");\n\n    return 0;\n}\n</code></pre>\n\n<p>Whenever I try to compile it using</p>\n\n<pre><code>gcc exl.c -o exl1\ncc exl.c -o exl1\n</code></pre>\n\n<p>or anything like that i just keep getting</p>\n\n<pre><code>gcc: error: exl.c: No such file or directory\ngcc: fatal error: No input files\ncompilation terminated.\n</code></pre>\n\n<p>I have no Idea what to do any help would be greatly appreciated.</p>\n\n<p>P.S. I have already done</p>\n\n<pre><code>sudo apt-get install build-essential\nsudo apt-get update build-essential\nsudo apt-get upgrade build-essential\n</code></pre>\n"},{"id":334760,"title":"File formats with gcc","body":"<p>I wrote some c code in a file and saved it with gedit. </p>\n\n<p>I then opened the terminal and tried compiling it with gcc but it gives me an error that it does not recognize the format of my c file. </p>\n\n<p>What format does gcc read?</p>\n"},{"id":372343,"title":"why do i get fwrite error while saving the data to a binary file?","body":"<p>have written a c program where packets are received from the network and saves it in a binary file called 'sniff_data.bin'. But during the compilation i am getting error as 'too few arguments to function fwrite'. What is wrong in my program? Can anybody help me out to solve it please? \n(In the program, handler used to open the binary file is 'logfile') here is my code:</p>\n\n<p>here is my code:</p>\n\n<pre><code>void ProcessPacket(unsigned char* , int);\nvoid print_ip_header(unsigned char* , int);\nvoid print_tcp_packet(unsigned char * , int );\nvoid print_udp_packet(unsigned char * , int );\nvoid print_icmp_packet(unsigned char* , int );\nvoid PrintData (unsigned char* , int);\n\nFILE *logfile;\nstruct sockaddr_in source,dest;\nint tcp=0,udp=0,icmp=0,others=0,igmp=0,total=0,i,j;\n\nint main()\n{ \nint saddr_size , data_size;\nstruct sockaddr saddr;\ngopromiscous();\nunsigned char *buffer = (unsigned char *) malloc(1024);  \n\nlogfile=fopen(\"sniff_data.bin\",\"wb\");\n\nif(logfile==NULL)\n{\n    printf(\"Unable to create sniff_data file.\");\n}\nprintf(\"\\n Starting..\\n\");\n\nint sock_raw = socket( AF_PACKET , SOCK_RAW , htons(ETH_P_ALL)) ;\n setsockopt(sock_raw , SOL_SOCKET , SO_BINDTODEVICE , \"eth0\" , strlen(\"eth0\")+ 1 );\n\nint count=30; \nwhile(count&gt;=0)\n{ \n    count--;\n    saddr_size = sizeof saddr;\n    //Receive a packet\n    data_size = recvfrom(sock_raw , buffer , 1024, 0 , &amp;saddr , \n(socklen_t*)&amp;saddr_size);\n    if(data_size &lt;0 )\n    {\n        printf(\"Recvfrom error , failed to get packets\\n\");\n        return 1;\n    }\n // if (fwrite(buffer, data_size, 1, logfile) != 1)\n\nfwrite(buffer, data_size, 1, logfile);\n\n    //Now process the packet\n    ProcessPacket(buffer , data_size);\n}\nfclose(logfile);\nclose(sock_raw);\nprintf(\"\\n\");\nprintf(\" Finished\\n\\n\");\nreturn 0;\n}\n\nvoid ProcessPacket(unsigned char* buffer, int size)\n\n{\n//Get the IP Header part of this packet , excluding the ethernet header\nstruct iphdr *iph = (struct iphdr*)(buffer + sizeof(struct ethhdr));\n++total;\nswitch (iph-&gt;protocol) //Check the Protocol and do accordingly...\n{\n    case 1:  //ICMP Protocol\n        ++icmp;\n        print_icmp_packet( buffer , size);\n        break;\n\n    case 2:  //IGMP Protocol\n        ++igmp;\n        break;\n\n    case 6:  //TCP Protocol\n        ++tcp;\n        print_tcp_packet(buffer , size);\n        break;\n\n    case 17: //UDP Protocol\n        ++udp;\n        print_udp_packet(buffer , size);\n        break;\n\n    default: //Some Other Protocol like ARP etc.\n        ++others;\n        break;\n}\nprintf(\"            TCP : %d   UDP : %d   ICMP : %d   IGMP : %d   Others : %d      \nTotal : %d\\r\", tcp , udp , icmp , igmp , others , total);\n}\n\nvoid print_ethernet_header(unsigned char* Buffer, int Size)\n{\nstruct ethhdr *eth = (struct ethhdr *)Buffer;\n\nfwrite(logfile , \"\\n\");\nfwrite(logfile , \"Ethernet Header\\n\");\nfwrite(logfile , \"   |-Destination Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X \\n\", \neth-&gt;h_dest[0] , eth-&gt;h_dest[1] , eth-&gt;h_dest[2] , eth-&gt;h_dest[3] , eth-&gt;h_dest[4] , \neth-&gt;h_dest[5] );\nfwrite(logfile , \"   |-Source Address      : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X \\n\", \neth-&gt;h_source[0] , eth-&gt;h_source[1] , eth-&gt;h_source[2] , eth-&gt;h_source[3] , \neth-&gt;h_source[4] , eth-&gt;h_source[5] );\nfwrite(logfile , \"   |-Protocol            : %u \\n\",(unsigned short)eth-&gt;h_proto);\n}\n\nvoid print_ip_header(unsigned char* Buffer, int Size)\n{\nprint_ethernet_header(Buffer , Size);\n\nunsigned short iphdrlen;\n\nstruct iphdr *iph = (struct iphdr *)(Buffer  + sizeof(struct ethhdr) );\niphdrlen =iph-&gt;ihl*4;\n\nmemset(&amp;source, 0, sizeof(source));\nsource.sin_addr.s_addr = iph-&gt;saddr;\n\nmemset(&amp;dest, 0, sizeof(dest));\ndest.sin_addr.s_addr = iph-&gt;daddr;\n\nfwrite(logfile , \"\\n\");\nfwrite(logfile , \"IP Header\\n\");\nfwrite(logfile , \"   |-IP Version        : %d\\n\",(unsigned int)iph-&gt;version);\nfwrite(logfile , \"   |-IP Header Length  : %d DWORDS or %d Bytes\\n\",(unsigned \nint)iph-&gt;ihl,((unsigned int)(iph-&gt;ihl))*4);\nfwrite(logfile , \"   |-Type Of Service   : %d\\n\",(unsigned int)iph-&gt;tos);\nfwrite(logfile , \"   |-IP Total Length   : %d  Bytes(Size of \nPacket)\\n\",ntohs(iph-&gt;tot_len));\nfwrite(logfile , \"   |-Identification    : %d\\n\",ntohs(iph-&gt;id));\n//fprintf(logfile , \"   |-Reserved ZERO Field   : %d\\n\",(unsigned \nint)iphdr-&gt;ip_reserved_zero);\n//fprintf(logfile , \"   |-Dont Fragment Field   : %d\\n\",(unsigned \nint)iphdr-&gt;ip_dont_fragment);\n//fprintf(logfile , \"   |-More Fragment Field   : %d\\n\",(unsigned \nint)iphdr-&gt;ip_more_fragment);\nfwrite(logfile , \"   |-TTL      : %d\\n\",(unsigned int)iph-&gt;ttl);\nfwrite(logfile , \"   |-Protocol : %d\\n\",(unsigned int)iph-&gt;protocol);\nfwrite(logfile , \"   |-Checksum : %d\\n\",ntohs(iph-&gt;check));\nfwrite(logfile , \"   |-Source IP        : %s\\n\",inet_ntoa(source.sin_addr));\nfwrite(logfile , \"   |-Destination IP   : %s\\n\",inet_ntoa(dest.sin_addr));\n}\n\nvoid print_tcp_packet(unsigned char* Buffer, int Size)\n{\nunsigned short iphdrlen;\n\nstruct iphdr *iph = (struct iphdr *)( Buffer  + sizeof(struct ethhdr) );\niphdrlen = iph-&gt;ihl*4;\n\nstruct tcphdr *tcph=(struct tcphdr*)(Buffer + iphdrlen + sizeof(struct ethhdr));\n\nint header_size =  sizeof(struct ethhdr) + iphdrlen + tcph-&gt;doff*4;\n\nfwrite(logfile , \"\\n\\n***********************TCP \nPacket*************************\\n\"); \n\nprint_ip_header(Buffer,Size);\n\nfwrite(logfile , \"\\n\");\nfwrite(logfile , \"TCP Header\\n\");\nfwrite(logfile , \"   |-Source Port      : %u\\n\",ntohs(tcph-&gt;source));\nfwrite(logfile , \"   |-Destination Port : %u\\n\",ntohs(tcph-&gt;dest));\nfwrite(logfile , \"   |-Sequence Number    : %u\\n\",ntohl(tcph-&gt;seq));\nfwrite(logfile , \"   |-Acknowledge Number : %u\\n\",ntohl(tcph-&gt;ack_seq));\nfwrite(logfile , \"   |-Header Length      : %d DWORDS or %d BYTES\\n\" ,(unsigned \nint)tcph-&gt;doff,(unsigned int)tcph-&gt;doff*4);\n//fprintf(logfile , \"   |-CWR Flag : %d\\n\",(unsigned int)tcph-&gt;cwr);\n//fprintf(logfile , \"   |-ECN Flag : %d\\n\",(unsigned int)tcph-&gt;ece);\nfwrite(logfile , \"   |-Urgent Flag          : %d\\n\",(unsigned int)tcph-&gt;urg);\nfwrite(logfile , \"   |-Acknowledgement Flag : %d\\n\",(unsigned int)tcph-&gt;ack);\nfwrite(logfile , \"   |-Push Flag            : %d\\n\",(unsigned int)tcph-&gt;psh);\nfwrite(logfile , \"   |-Reset Flag           : %d\\n\",(unsigned int)tcph-&gt;rst);\nfwrite(logfile , \"   |-Synchronise Flag     : %d\\n\",(unsigned int)tcph-&gt;syn);\nfwrite(logfile , \"   |-Finish Flag          : %d\\n\",(unsigned int)tcph-&gt;fin);\nfwrite(logfile , \"   |-Window         : %d\\n\",ntohs(tcph-&gt;window));\nfwrite(logfile , \"   |-Checksum       : %d\\n\",ntohs(tcph-&gt;check));\nfwrite(logfile , \"   |-Urgent Pointer : %d\\n\",tcph-&gt;urg_ptr);\nfwrite(logfile , \"\\n\");\nfwrite(logfile , \"                        DATA Dump                         \");\nfwrite(logfile , \"\\n\");\n\nfwrite(logfile , \"IP Header\\n\");\nPrintData(Buffer,iphdrlen);\n\nfwrite(logfile , \"TCP Header\\n\");\nPrintData(Buffer+iphdrlen,tcph-&gt;doff*4);\n\nfwrite(logfile , \"Data Payload\\n\");   \nPrintData(Buffer + header_size , Size - header_size );\n\nfwrite(logfile , \"\\n###########################################################\");\n}\n\nvoid print_udp_packet(unsigned char *Buffer , int Size)\n{\n\n unsigned short iphdrlen;\n\n struct iphdr *iph = (struct iphdr *)(Buffer +  sizeof(struct ethhdr));\n iphdrlen = iph-&gt;ihl*4;\n\n struct udphdr *udph = (struct udphdr*)(Buffer + iphdrlen  + sizeof(struct ethhdr));\n\n int header_size =  sizeof(struct ethhdr) + iphdrlen + sizeof udph;\n\n  fwrite(logfile , \"\\n\\n***********************UDP \n Packet*************************\\n\");\n\nprint_ip_header(Buffer,Size);          \n\nfwrite(logfile , \"\\nUDP Header\\n\");\nfwrite(logfile , \"   |-Source Port      : %d\\n\" , ntohs(udph-&gt;source));\nfwrite(logfile , \"   |-Destination Port : %d\\n\" , ntohs(udph-&gt;dest));\nfwrite(logfile , \"   |-UDP Length       : %d\\n\" , ntohs(udph-&gt;len));\nfwrite(logfile , \"   |-UDP Checksum     : %d\\n\" , ntohs(udph-&gt;check));\n\nfwrite(logfile , \"\\n\");\nfwrite(logfile , \"IP Header\\n\");\nPrintData(Buffer , iphdrlen);\n\nfwrite(logfile , \"UDP Header\\n\");\nPrintData(Buffer+iphdrlen , sizeof udph);\n\nfwrite(logfile , \"Data Payload\\n\");   \n\n//Move the pointer ahead and reduce the size of string\nPrintData(Buffer + header_size , Size - header_size);\n\nfwrite(logfile , \"\\n###########################################################\");\n }\n\nvoid print_icmp_packet(unsigned char* Buffer , int Size)\n{\nunsigned short iphdrlen;\n\nstruct iphdr *iph = (struct iphdr *)(Buffer  + sizeof(struct ethhdr));\niphdrlen = iph-&gt;ihl * 4;\n\nstruct icmphdr *icmph = (struct icmphdr *)(Buffer + iphdrlen  + sizeof(struct   \nethhdr));\n\nint header_size =  sizeof(struct ethhdr) + iphdrlen + sizeof icmph;\n\nfwrite(logfile , \"\\n\\n***********************ICMP \nPacket*************************\\n\");\n\nprint_ip_header(Buffer , Size);\n\nfwrite(logfile , \"\\n\");\n\nfwrite(logfile , \"ICMP Header\\n\");\nfwrite(logfile , \"   |-Type : %d\",(unsigned int)(icmph-&gt;type));\n\nif((unsigned int)(icmph-&gt;type) == 11)\n{\n    fwrite(logfile , \"  (TTL Expired)\\n\");\n}\nelse if((unsigned int)(icmph-&gt;type) == ICMP_ECHOREPLY)\n{\n    fwrite(logfile , \"  (ICMP Echo Reply)\\n\");\n}\n\nfwrite(logfile , \"   |-Code : %d\\n\",(unsigned int)(icmph-&gt;code));\nfwrite(logfile , \"   |-Checksum : %d\\n\",ntohs(icmph-&gt;checksum));\n//fprintf(logfile , \"   |-ID       : %d\\n\",ntohs(icmph-&gt;id));\n//fprintf(logfile , \"   |-Sequence : %d\\n\",ntohs(icmph-&gt;sequence));\nfwrite(logfile , \"\\n\");\n\nfwrite(logfile , \"IP Header\\n\");\nPrintData(Buffer,iphdrlen);\n\nfwrite(logfile , \"UDP Header\\n\");\nPrintData(Buffer + iphdrlen , sizeof icmph);\n\nfwrite(logfile , \"Data Payload\\n\");   \n\n//Move the pointer ahead and reduce the size of string\nPrintData(Buffer + header_size , (Size - header_size) );\n\nfwrite(logfile , \"\\n###########################################################\");\n}\n\n\nint gopromiscous()\n{\n\n    int fd;\n    struct ifreq eth;\n\n    fd = socket(AF_INET, SOCK_PACKET, htons(0x800));\n\n    strcpy(eth.ifr_name, \"eth0\");\n\n    ioctl(fd, SIOCGIFFLAGS, &amp;eth);\n\n    eth.ifr_flags |= IFF_PROMISC;\n\n    ioctl(fd, SIOCSIFFLAGS, &amp;eth);\n    printf(\"\\n Entered Promiscuous Mode Successfully\\n\");\n\n}\n\n\n\n\nvoid PrintData (unsigned char* data , int Size)\n{\nint i , j;\nfor(i=0 ; i &lt; Size ; i++)\n{\n    if( i!=0 &amp;&amp; i%16==0)   //if one line of hex printing is complete...\n    {\n        fwrite(logfile , \"         \");\n        for(j=i-16 ; j&lt;i ; j++)\n        {\n            if(data[j]&gt;=32 &amp;&amp; data[j]&lt;=128)\n                fwrite(logfile , \"%c\",(unsigned char)data[j]); //if its a number or \n alphabet\n\n            else fwrite(logfile , \".\"); //otherwise print a dot\n        }\n        fwrite(logfile , \"\\n\");\n    }\n\n    if(i%16==0) fwrite(logfile , \"   \");\n        fwrite(logfile , \" %02X\",(unsigned int)data[i]);\n\n    if( i==Size-1)  //print the last spaces\n    {\n        for(j=0;j&lt;15-i%16;j++)\n        {\n          fwrite(logfile , \"   \"); //extra spaces\n        }\n\n        fwrite(logfile , \"         \");\n\n        for(j=i-i%16 ; j&lt;=i ; j++)\n        {\n            if(data[j]&gt;=32 &amp;&amp; data[j]&lt;=128)\n            {\n              fwrite(logfile , \"%c\",(unsigned char)data[j]);\n            }\n            else\n            {\n              fwrite(logfile , \".\");\n            }\n        }\n\n        fwrite(logfile ,  \"\\n\" );\n    }\n  }\n }\n</code></pre>\n"},{"id":244913,"title":"Compiling C programs on Ubuntu 12.04","body":"<p>I'm an absolute beginner at writing programs in C, and I'm having difficulty compiling a simple program. Here's my code:</p>\n\n<pre><code>/* This code is a .c file that prints out the words hello, world. */\n\n# include &lt;stdio.h&gt;\nint main()\n{\n    printf(\"Hello World! \\n\");\n}\n</code></pre>\n\n<p>Here's the error I get when compiling:</p>\n\n<pre><code>Ubuntu:~/Desktop/cFiles$ gcc -Wall hello.c -o hello.out -lmls \nhello.c:5:1: warning: return type defaults to ‘int’ [-Wreturn-type]\nhello.c: In function ‘main’:\nhello.c:7:3: warning: implicit declaration of function ‘print’ [-Wimplicit-function-declaration]\nhello.c:8:1: warning: control reaches end of non-void function [-Wreturn-type] /usr/bin/ld: cannot find -lmls\ncollect2: ld returned 1 exit status\n</code></pre>\n\n<p>I'm not sure what I'm doing wrong. Can anyone help?</p>\n"},{"id":220566,"title":"Problems compiling Library","body":"<p>I am having some difficulties compiling some files that I downloaded (for academic purposes). \nI ran the following command :</p>\n\n<pre><code>cd tmp/Detri_2.6.a/detri\n</code></pre>\n\n<p>then\n    make detri_new CC=gcc\nTo build a library from the relevant files and folders extracted to /tmp.</p>\n\n<p>The output is as follows:</p>\n\n<pre><code>tmp/Detri_2.6.a/detri$ make detri_new CC=gcc\ng++     Makefile.cpp   -o Makefile\n\nMakefile.cpp:16:25: error: expected unqualified-id before ‘-’ token\nMakefile.cpp:16:38: error: expected unqualified-id before ‘-’ token\nMakefile.cpp:17:1: error: ‘LIBS’ does not name a type\nMakefile.cpp:20:1: error: ‘MODULES’ does not name a type\n[..]\nMakefile.cpp:65:73: error: expected unqualified-id before ‘-’ token\nMakefile.cpp:68:1: error: expected unqualified-id before ‘.’ token\nMakefile.cpp:68:19: error: ‘$’ does not name a type\nMakefile.cpp:68:60: error: expected unqualified-id before ‘-’ token\nMakefile.cpp:71:10: error: ‘$’ does not name a type\nMakefile.cpp:71:20: error: expected unqualified-id before ‘-’ token\nMakefile.cpp:71:31: error: expected unqualified-id before ‘--’ token\nMakefile.cpp:71:43: error: ‘$’ does not name a type\nmake: *** [Makefile] Error 1\n</code></pre>\n\n<p>></p>\n\n<p>I haven't written the makefile.cpp (please bear in mind this is my  first week of using ubuntu and doing this sort of thing) but previously, the compiler would attempt to build and find an error in the makefile.tmp, not in the .cpp file. Now as the output shows, it isn't going past the point of trying to read the .cpp file.</p>\n\n<p>I am a bit lost here...</p>\n\n<p>Thank you</p>\n\n<p>UPDATE: I have tried what was suggested in the comment below, i.e. running :\n    make -k TMPMK=Makefile.tmp  detri_new CC=gcc</p>\n\n<p>Yet I still have the same (window full of) output errors, plus some new ones.</p>\n\n<p>If this is of any help, the code was obtained from the following <a href=\"http://www.geom.uiuc.edu/software/cglist/GeomDir/#DETRI\" rel=\"nofollow\">website</a></p>\n\n<p>EDIT: Shortened error output section and clearer explanation of the problem.</p>\n\n<p>Here is the makefile :</p>\n\n<pre><code>/* detri/Makefile.cpp --- C pre-processor Makefile for detri. */\n\n/* USAGE: cpp -P ${CPPMK} &gt; ${TMPMK}; make -k TMPMK=${TMPMK} -f ${TMPMK} ... */\n\n/* Targets.  (CHANGE THIS ACCORDING TO YOUR NEEDS!) */\nDEST=    ../bin\nLIB=     ../lib\nINCLUDE= ../include\n\n/* Paramters: DEPEND, SHELL, CC, CPP, CPPMK, TMPMK, COPT. */\n/* System specifics: CCFLAGS, AR, RANLIB, MALLOC. */\n#include \"Makefile.sys\"\n\n/* Other libraries. */\nINCLS= -I${INCLUDE}\nLIBRARIES= -l_sos${DBX} -l_lia${DBX} -l_basic${DBX}\nLIBS= -L${LIB}\n\n/* Source and object files. */\nMODULES= detri.c delaunay.c flip.c prep.c \\\n         dt.c print_dt.c search.c trist.c peel.c\nH_FILES= detri.h dt.h trist.h\nOBJECTS= ${MODULES:.c=.o}\n\n/* Interface. */\nnormal: detri;  @echo \"Detri ready.\"\ndebug:  ;       ${MAKE} -k -f ${TMPMK} detri COPT=\"-D__DEBUG__\" DBX=-g\nremove: ;       rm -f ${OBJECTS}\nall:    normal;\n\n/* BEGIN Meta Interface: make detri_new */\n/* Note: This is here so that we can package Detri stand-alone,\n   without the alpha shape software and it's top-level Makefile. */\n\nBASIC= ../basic\nLIA=   ../lia\nSOS=   ../sos\nDETRI= ./\n\nHD=echo \"\\n\\n*** X ***\\n\"\nMK= ${MAKE} -k CC=\"${CC}\" CPP=\"${CPP}\" COPT=\"${COPT}\"\n\ndetri_new:;   ${MK} check soslibs_           detri_\ndetri_debug:; ${MK} check soslibs_d          detri_d\ndetri_all:;   ${MK} check soslibs_d soslibs_ detri_\nsoslibs_:  basic_ lia_ sos_\ndetri_:;  @/bin/csh -cf '${HD:X=Detri}; cd ${DETRI}; ${MK} new'\nsos_:;    @/bin/csh -cf '${HD:X=SoS};   cd ${SOS};   ${MK} new'\nlia_:;    @/bin/csh -cf '${HD:X=Lia};   cd ${LIA};   ${MK} new'\nbasic_:;  @/bin/csh -cf '${HD:X=Basic}; cd ${BASIC}; ${MK} new'\nsoslibs_d: basic_d lia_d sos_d\ndetri_d:; @/bin/csh -cf '${HD:X=Detri}; cd ${DETRI}; ${MK} clear debug'\nsos_d:;   @/bin/csh -cf '${HD:X=SoS};   cd ${SOS};   ${MK} clear debug'\nlia_d:;   @/bin/csh -cf '${HD:X=Lia};   cd ${LIA};   ${MK} clear debug'\nbasic_d:; @/bin/csh -cf '${HD:X=Basic}; cd ${BASIC}; ${MK} clear debug'\ncheck:;   @/bin/csh -cf '           \\\n  echo Checking for target dirs;     \\\n  if (! -e ${DEST})    mkdir ${DEST}; \\\n  if (! -e ${LIB})     mkdir ${LIB};   \\\n  if (! -e ${INCLUDE}) mkdir ${INCLUDE} \\\n'\n\n/* Internal rules. */\ndetri: ${OBJECTS}; ${CC} ${CCFLAGS} ${DBX} ${COPT} ${OBJECTS} \\\n                        -o ${DEST}/detri ${LIBS} ${LIBRARIES} ${MALLOC} -lm;\n\n/* Generic rule to compile source files. */\n.c.o: ${H_FILES}; ${CC} ${CCFLAGS} ${DBX} ${COPT} ${INCLS} -c $*.c -o $*.o\n\n/* To compute dependencies with \"make depend\" ... */\ndepend:; ${DEPEND} -f${TMPMK} -- ${INCLS} ${MODULES}\n</code></pre>\n"}]}]